#pragma config(Sensor, in1,    hyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           rbd,           tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lbd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           lfd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rfd,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lift4,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           claw1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw2,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "buttonTracker.c"
#include "parallelDrive.c"
#include "pd_autoMove.c"
#include "motorGroup.c"

//buttons
#define toggleLiftModeBtn Btn8U
#define openClawBtn Btn6D //claw
#define closeClawBtn Btn6U
#define liftUpBtn Btn5U //lift
#define liftDownBtn Btn5D

//positions
#define liftBottom 100 //lift
#define liftMiddle 795
#define liftVert 3690
#define clawOpenPos 1000 //claw
#define clawClosedPos 200

//constants
#define liftStillSpeed 10
#define clawStillSpeed 15

//variables
short clawOpen = false;

motorGroup lift;
motorGroup claw;

void pre_auton() {
	bStopTasksBetweenModes = true;

	initializeDrive(drive);
  setDriveMotors(drive, 4, lfd, lbd, rfd, rbd);
  attachEncoder(drive, leftEnc, LEFT);
  attachEncoder(drive, rightEnc, RIGHT, true, 4);
  attachGyro(drive, hyro);

	initializeGroup(lift, 4, lift1, lift2, lift3, lift4);
  configureButtonInput(lift, liftUpBtn, liftDownBtn, liftStillSpeed);
  addSensor(lift, liftPot);

  initializeGroup(claw, 2, claw1, claw2);
}

//autonomous region
void deployClaw(int waitAtEnd=250) {
	setDrivePower(drive, 127, 127);
	wait1Msec(500);
	setDrivePower(drive, -127, -127);
	wait1Msec(750);
	setDrivePower(drive, 0, 0);
	wait1Msec(waitAtEnd);
}

void setClawStateManeuver(bool open = !clawOpen) { //toggles by default
	if (open) {
		clawOpen = true;
		createManeuver(claw, clawOpenPos, clawStillSpeed);
	} else {
		clawOpen = false;
		createManeuver(claw, clawClosedPos, clawStillSpeed);
	}
}

void setLiftStateManeuver(bool top = potentiometerVal(lift)<liftMiddle) { //toggles by default
  if (top) {
    createManeuver(lift, liftVert, -liftStillSpeed);
  } else {
    createManeuver(lift, liftBottom, liftStillSpeed);
  }
}

task autonomous() {
	//deploy stops
	goToPosition(lift, 725);
	goToPosition(lift, 525);

  deployClaw();

  driveStraight(5, true); //drive away from wall
  createClawStateManeuver(true); //open claw
  while (driveData.isDriving || claw.maneuverExecuting) executeManeuver(claw);

  //move toward pillow
  turn(-45);
  driveStraight(20);

  goToPosition(claw, clawClosedPos); //clamp pillow

  setLiftStateManeuver(true);
  turn(-135, true); //turn so back faces fence
  while (turnData.isTurning || lift.maneuverExecuting) executeManeuver(lift);
  driveStraight(-20, true); // back up to wall
  while (driveData.isDriving || lift.maneuverExecuting) executeManeuver(lift);

  goToPosition(claw, clawOpenPos); //release pillow
}
//end autonomous region

//user control region
void liftControl() {
	short potPos = potentiometerVal(lift);
	lift.stillSpeed = liftStillSpeed * ((potPos<liftMiddle || potPos>liftVert) ? -1 : 1);
	takeInput(lift);
}

void clawControl() {
	if (vexRT[closeClawBtn] == 1) {
		setPower(claw, 127);
		clawOpen = false;
	} else if (vexRT[openClawBtn] == 1) {
		setPower(claw, -127);
		clawOpen = true;
	} else {
		setPower(claw, clawStillSpeed * (clawOpen ? 1 : -1));
	}
}

task usercontrol() {
	while (true) {
  	driveRuntime(drive);

  	liftControl();

		clawControl();
  }
}
//end user control region
