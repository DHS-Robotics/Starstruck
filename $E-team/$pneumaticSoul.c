#pragma config(Sensor, in1,    hyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorNone)
#pragma config(Sensor, in3,    clawPotL,       sensorPotentiometer)
#pragma config(Sensor, in4,    clawPotR,       sensorPotentiometer)
#pragma config(Sensor, in5,    sidePot,        sensorPotentiometer)
#pragma config(Sensor, in6,    modePot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           rd1,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ld1,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           clawR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rd2,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           clawL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ld2,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ld3,           tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#region setup
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#include "..\Includes\pd_autoMove.c"
//#endregion

//#region buttons
#define autoDumpOnBtn			Btn8U	//claw
#define autoDumpOffBtn		Btn8D
#define discreteModeBtn		Btn7U
#define continuousModeBtn	Btn7D
#define openClawBtn				Btn6U
#define closeClawBtn			Btn6D
#define hyperExtendBtn		Btn7R
#define liftUpBtn					Btn5U //lift
#define liftDownBtn				Btn5D
//#endregion

//#region positions
#define liftBottom 15 //lift
#define liftMiddle 76
#define liftTop 260
#define liftThrowPos 400
#define liftMax 520
#define clawClosedPos 400 //claw
#define clawOpenPos 1150
#define clawMax 2000
//#endregion

//#region constants
#define liftStillSpeed 10		//still speeds
#define clawStillSpeed 10
#define fenceToWallDist 31	//distances
#define clawDiff 0				//difference between claw potentiometers when at the same angle (left - right)
//#endregion

//#region config
#define straightToCube true
#define blocking false
//#endregion

//#region globals
bool clawOpen = true;
bool continuousMode = true;	//whether claw is in continuous or discrete control mode
bool liftDown = true;
bool autoDumping = true;
int autoSign; //for autonomous, positive if robot is left of pillow

motorGroup lift;
motorGroup rightClaw;
motorGroup leftClaw;
motorGroup claw;

PID clawMatchingPID;	//for matching left to right during continuous control
PID clawR_PID;				//for moving right during discrete control
PID clawL_PID;				//for moving left durng discrete control
//#endregion

//#region enums
enum clawState { CLOSED, OPEN, HYPEREXTENDED };
enum liftState { BOTTOM, MIDDLE, TOP, THROW, MAX };
//#endregion

void pre_auton() {
	bStopTasksBetweenModes = true;

	initializeAutoMovement();

	turnDefaults.rampConst1 = 60;
	turnDefaults.rampConst2 = 127;
	turnDefaults.rampConst3 = -10;

	driveDefaults.rampConst1 = 60;
	driveDefaults.rampConst2 = 127;
	driveDefaults.rampConst3 = -20;

	//configure drive
	initializeDrive(drive);
	setDriveMotors(drive, 6, ld1, ld2, ld3, rd1, rd2, rd2);
	attachEncoder(drive, leftEnc, LEFT);
	attachEncoder(drive, rightEnc, RIGHT, false, 2.75);
	attachGyro(drive, hyro);

	//configure lift
	initializeGroup(lift, 3, lift1, lift2, lift3);
	configureButtonInput(lift, liftUpBtn, liftDownBtn, liftStillSpeed);
	addSensor(lift, liftPot, true);

	//configure claw
	initializeGroup(claw, 2, clawR, clawL);

	initializeGroup(rightClaw, 1, clawR);	//master side
	addSensor(rightClaw, clawPotR);

	initializeGroup(leftClaw, 1, clawL);	//slave side
	addSensor(leftClaw, clawPotL);

	initializePID(clawMatchingPID, getPosition(rightClaw)+clawDiff, 0.2, 0, 0.7, 25);
	initializePID(clawL_PID, getPosition(leftClaw), 0.2, 0, 0.7, 25);
	initializePID(clawR_PID, getPosition(rightClaw), 0.2, 0, 0.7, 25);
}

//#region lift
void liftEncCorrection() {
	if (getPosition(lift) < 0)
		resetEncoder(lift);
}

void liftControl() {
	liftEncCorrection();

	lift.stillSpeed = liftStillSpeed * (getPosition(lift)<liftMiddle ? -1 : 1);

	takeInput(lift);
}
//#endregion

//#region claw
void matchClaws() {
	clawMatchingPID.target = getPosition(rightClaw) + clawDiff;
	setPower(leftClaw, PID_runtime(clawMatchingPID, getPosition(leftClaw)));
}

void executeClawPIDs() {
	setPower(leftClaw,	PID_runtime(clawL_PID, getPosition(leftClaw)));
	setPower(rightClaw, PID_runtime(clawR_PID, getPosition(rightClaw)));
}

void setClawTargets(int leftTarget, int rightTarget) {
	clawL_PID.target = leftTarget;
	clawR_PID.target = rightTarget;
}

void continuousClaw() {
	if (vexRT[openClawBtn] == 1) {	//opening
		setPower(claw, 127);
		clawOpen = true;
	} else if (vexRT[closeClawBtn] == 1) {	//closing
		setPower(claw, -127);
		clawOpen = false;
	} else if (getPosition(lift)>liftThrowPos && autoDumping) {	//autodumping
		clawOpen = true;
		setClawTargets(clawOpenPos+clawDiff, clawOpenPos);
		executeClawPIDs();
	} else {
		setPower(rightClaw, (clawOpen ? 0 : -clawStillSpeed));
		matchClaws();
	}
}

void discreteClaw() {
	if (vexRT[openClawBtn] == 1)
		setClawTargets(clawOpenPos+clawDiff, clawOpenPos);
	else if (vexRT[closeClawBtn] == 1)
		setClawTargets(clawClosedPos+clawDiff, clawClosedPos);
	else if (vexRT[hyperExtendBtn] == 1)
		setClawTargets(clawMax+clawDiff, clawMax);
	else if (getPosition(lift)>liftThrowPos && autoDumping)
		setClawTargets(clawOpenPos+clawDiff, clawOpenPos);

	executeClawPIDs();
}

void clawControl() {
	if (vexRT[continuousModeBtn] == 1) {
		continuousMode = true;
	} else {
		continuousMode = false;
		setClawTargets(getPosition(leftClaw), getPosition(rightClaw));
	}

	if (continuousMode)
		continuousClaw();
	else
		discreteClaw();

	if (vexRT[autoDumpOnBtn] == 1)
		autoDumping = true;
	else if (vexRT[autoDumpOffBtn] == 1)
		autoDumping = false;
}
//#endregion

//#region autonomous
int getAvgClawPos() {
	return (getPosition(rightClaw) + getPosition(leftClaw) + clawDiff) / 2;
}

bool clawManeuverExecuting() {
	return rightClaw.maneuverExecuting || leftClaw.maneuverExecuting;
}

void executeClawManeuvers() {
	executeManeuver(leftClaw);
	executeManeuver(rightClaw);
}

void maneuvers() {
	executeClawManeuvers();

	if (lift.maneuverExecuting)
		executeManeuver(lift);
	else
		liftEncCorrection();
}

void createClawManeuver(clawState state, int power=127) {
	switch (state) {
		case CLOSED:
			createManeuver(leftClaw,	clawClosedPos+clawDiff, -clawStillSpeed, power);
			createManeuver(rightClaw, clawClosedPos,					-clawStillSpeed, power);
			clawOpen = false;
			break;
		case OPEN:
			createManeuver(leftClaw,	clawOpenPos+clawDiff, 0, power);
			createManeuver(rightClaw, clawOpenPos,					0, power);
			clawOpen = true;
			break;
		case HYPEREXTENDED:
			createManeuver(leftClaw,	clawMax+clawDiff, 0, power);
			createManeuver(rightClaw,	clawMax,					0, power);
			clawOpen = true;
			break;
	}
}

void openClaw(int power=127) {
	createClawManeuver(OPEN, power);
	while (clawManeuverExecuting()) executeClawManeuvers();

	clawOpen = true;
}

void closeClaw(int timeout=750, int power=127, int minSpeed=25, int sampleTime=100) { //minSpeed in encoder/potentiometer values per second
	int minDiffPerSample = minSpeed * sampleTime / 1000;
	int prevPos = getAvgClawPos();
	int newPos;
	long clawTimer = resetTimer();

	setPower(claw, -127);

	while (time(clawTimer)<timeout || getPosition(claw)>clawOpenPos) {
		wait1Msec(sampleTime);
		newPos = getAvgClawPos();

		if (newPos - prevPos > minDiffPerSample) clawTimer = resetTimer();

		prevPos = newPos;
	}

	setPower(claw, 0);

	clawOpen = false;
}

void hyperExtendClaw(int power=127) {
	createClawManeuver(HYPEREXTENDED, power);
	while (clawManeuverExecuting()) executeClawManeuvers();

	clawOpen = true;
}

void createLiftManeuver(liftState state, int power=127) {
	liftDown = false;

	switch (state) {
		case BOTTOM:
			createManeuver(lift, liftBottom, -liftStillSpeed, power);
			liftDown = true;
			break;
		case MIDDLE:
			createManeuver(lift, liftMiddle, liftStillSpeed, power);
			break;
		case TOP:
			createManeuver(lift, liftTop, liftStillSpeed, power);
			break;
		case THROW:
			createManeuver(lift, liftThrowPos, liftStillSpeed, power);
			break;
		case MAX:
			createManeuver(lift, liftMax, liftStillSpeed, power);
			break;
	}
}

void liftTo(liftState state, int power=127) {
	liftDown = false;

	switch (state) {
		case BOTTOM:
			goToPosition(lift, liftBottom, -liftStillSpeed, power);
			liftDown = true;
			break;
		case MIDDLE:
			goToPosition(lift, liftMiddle, liftStillSpeed, power);
			break;
		case TOP:
			goToPosition(lift, liftTop, liftStillSpeed, power);
			break;
		case THROW:
			goToPosition(lift, liftThrowPos, liftStillSpeed, power);
			break;
		case MAX:
			goToPosition(lift, liftMax, liftStillSpeed, power);
			break;
	}
}

void turnDriveDump (int angle, int dist, int distCutoff=0, float turnConst1=turnDefaults.rampConst1, float turnConst2=turnDefaults.rampConst2, float turnConst3=turnDefaults.rampConst3) {
	if (angle != 0) { //turning
		if (dist != 0) { //turning & driving
			if (liftDown) liftTo(MIDDLE); //lift up so claw doesn't drag on ground
			turn(angle, false, turnConst1, turnConst2, turnConst3); //turn
		} else { //turning but not driving
			turn (angle, true, turnConst1, turnConst2, turnConst3); //turn
			while (abs(turnProgress()) < distCutoff); //wait to throw
		}
	}

	if (dist != 0) { //driving
		driveStraight(dist, true); //drive
		while (driveData.totalDist < distCutoff); //wait to throw
	}

	createLiftManeuver(MAX);
	while (getPosition(lift) < liftThrowPos) maneuvers();
	createClawManeuver(OPEN);
	while (turnData.isTurning || driveData.isDriving || lift.maneuverExecuting || claw.maneuverExecuting) maneuvers();
}

void grabNdump(int delayDuration, int dist=fenceToWallDist, int closeTimeout=500) {
	wait1Msec(delayDuration); //wait for objects to be dropped
	closeClaw(closeTimeout);
	turnDriveDump(0, -dist); //dump pillow
}

void driveToWall(int distance=fenceToWallDist) {
	liftTo(BOTTOM);
	driveStraight(distance);
}

void ramToRealign(int duration=500) {
	liftTo(BOTTOM);

	setDrivePower(drive, -127, -127); //realign using wall
	wait1Msec(duration);
}

void initialPillow(bool liftToMid=false) {
	setPower(lift, -liftStillSpeed);
	if (liftToMid) createManeuver(lift, liftMiddle - 65, liftStillSpeed, 30);

	if (straightToCube) {
		driveStraight(18);
	} else {
		//open claw and drive away from wall
		createClawManeuver(OPEN);
		driveStraight(5, true);
		while(driveData.isDriving) maneuvers();

		//drive to central pillow
		turn(autoSign * -47, true);
		while(turnData.isTurning || claw.maneuverExecuting) maneuvers();
		driveStraight(14);
	}

	closeClaw(500); //clamp pillow
}

task skillz() {
	createClawManeuver(OPEN);
	driveStraight(-11, true);
	while (claw.maneuverExecuting || driveData.isDriving) maneuvers();

	grabNdump(3000);

	for (int i=0; i<2; i++) { //dump preload pillows
		ramToRealign();

		driveStraight(fenceToWallDist);

		grabNdump(500);
	}

	ramToRealign();

	//get and dump front center jacks
	createManeuver(lift, liftMiddle+10, liftStillSpeed);
	createManeuver(claw, clawClosedPos-75);
	driveStraight(4.75, true);
	while (driveData.isDriving || lift.maneuverExecuting) maneuvers();
	turn(-80, true, 60, 127, -10);
	while (turnData.isTurning || claw.maneuverExecuting) maneuvers();
	liftTo(BOTTOM);
	driveStraight(29);
	closeClaw();
	driveStraight(-6);
	turnDriveDump(67, 0);

	//get and dump pillow in center of field
	createLiftManeuver(BOTTOM);
	driveStraight(-5, true);	//to align to central pillow
	while (driveData.isDriving || lift.maneuverExecuting) maneuvers();
	driveStraight(10);
	closeClaw(); //grab pillow
	turnDriveDump(0, -10);

	//grab and dump center back jacks
	driveStraight(fenceToWallDist+1.5, true);
	createClawManeuver(HYPEREXTENDED);
	createLiftManeuver(BOTTOM);
	while (driveData.isDriving || claw.maneuverExecuting || lift.maneuverExecuting) maneuvers();
	grabNdump(0, 30, 750);

	//get and dump pillow
	createLiftManeuver(BOTTOM);
	turn(-13, true);
	while (lift.maneuverExecuting || turnData.isTurning) maneuvers();
	driveStraight(29);
	closeClaw();
	turnDriveDump(40, -30, 10);

	ramToRealign();
	driveStraight(fenceToWallDist);
	grabNdump(500);

	ramToRealign();
	driveStraight(fenceToWallDist+3);
	grabNdump(500, 35);

	liftTo(BOTTOM);
}

task pillowAuton() {
	clearTimer(T1);
	initialPillow(true);

	//go to fence and lift up
	createLiftManeuver(TOP);
	driveStraight(8.5, true);
	while (driveData.isDriving) maneuvers();
	turn(autoSign * 37, true, 60, 127, -15); //turn to face fence
	while (turnData.isTurning) maneuvers();
	driveStraight(20, true); // drive up to wall
	while (driveData.isDriving || lift.maneuverExecuting) maneuvers();

	if (blocking)
		while (time1(T1) < 12000);
	openClaw(); //release pillow
	wait1Msec(750); //wait for pillow to fall
	closeClaw();
	driveStraight(-6); //back up
	hyperExtendClaw();

	//push jacks over
 	driveStraight(8);
 	closeClaw();

 	createClawManeuver(HYPEREXTENDED);

 	//drive to other wall and lift down
 	driveStraight(-10, true);
 	while (driveData.isDriving) maneuvers();
 	turn(autoSign * 74, true, 60, 127, -15);
 	while (turnData.isTurning || claw.maneuverExecuting) maneuvers();
 	createManeuver(lift, liftMiddle+100, liftStillSpeed);
 	driveStraight(33, true, driveDefaults.rampConst1, driveDefaults.rampConst2, -10);
 	while (driveData.isDriving || lift.maneuverExecuting) maneuvers();
 	turn(autoSign * -85, false, 40, 120, -40);
 	driveStraight(11);

 	goToPosition(lift, liftTop+50, -liftStillSpeed); //push jacks over
 	driveStraight(5);
 	closeClaw();
}

task dumpyAuton() {
	initialPillow();

	//createManeuver(lift, liftMiddle+10, liftStillSpeed);
	//goToPosition(lift, liftMiddle+10, liftStill
	liftTo(MIDDLE);
	driveStraight(8);
	//wait1Msec(500);

	turnDriveDump(autoSign * -97, -17, 7, 45, 120, -20);
	//wait1Msec(250);

	//driveToWall();
	createLiftManeuver(BOTTOM);
	createClawManeuver(HYPEREXTENDED);
	while (lift.maneuverExecuting || claw.maneuverExecuting) maneuvers();
	driveStraight(fenceToWallDist);
	grabNdump(0, 33, 750);
	driveToWall();
	grabNdump(0, 33, 750);

	liftTo(BOTTOM);
}

task oneSideAuton() {
	//createClawManeuver(HYPEREXTENDED); //open claw
	createManeuver(lift, liftTop-450, liftStillSpeed); //lift to near top
	driveStraight(-5, true); //drive away from wall
	while(driveData.isDriving) maneuvers();

	turn(autoSign * 30, true);
	while (turnData.isTurning) maneuvers();

	driveStraight(-12, true);
	while (driveData.isDriving || claw.maneuverExecuting) maneuvers();

	turn(autoSign * -30, true); //turn toward wall
	while (turnData.isTurning || lift.maneuverExecuting) maneuvers();

	//knock off jacks
	driveStraight(-25);
	liftTo(MAX);
	closeClaw();

	//pick up and dump back jacks
	createClawManeuver(OPEN);
	createLiftManeuver(BOTTOM);
	while (claw.maneuverExecuting || lift.maneuverExecuting) maneuvers();
	//turn(autoSign * -3);
	driveStraight(29);
	closeClaw();
	turnDriveDump(autoSign * 0, -35, 20);
}

task autonomous() {
	lift.maneuverExecuting = false;
	claw.maneuverExecuting = false;
	resetEncoder(lift);

	int sidePos = SensorValue[sidePot];

	autoSign = (sidePos > 1830) ? 1 : -1;

	//start appropriate autonomous task
	if (1290<sidePos && sidePos<2470) {
		startTask(skillz);
	} else if (SensorValue[modePot] < 385) {
		startTask(pillowAuton);
	} else if (SensorValue[modePot] < 1765) {
		startTask(dumpyAuton);
	} else if (SensorValue[modePot] > 3300) {
		startTask(oneSideAuton);
	}
}
//#endregion

task usercontrol() {
	lift.maneuverExecuting = false;
	claw.maneuverExecuting = false;

	while (true) {
		driveRuntime(drive);

		liftControl();

		clawControl();
	}
}
