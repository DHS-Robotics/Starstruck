#pragma config(Sensor, in1,    hyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    clawPotR,       sensorPotentiometer)
#pragma config(Sensor, in4,    clawPotL,       sensorPotentiometer)
#pragma config(Sensor, in5,    modePot,        sensorPotentiometer)
#pragma config(Sensor, in6,    sidePot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           ld1,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rd1,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           clawR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ld2,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rd2,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rd3,           tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#region setup
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#include "..\Includes\pd_autoMove.c"
//#endregion

//#region buttons
	//#subregion claw
#define autoDumpOnBtn			Btn8U
#define autoDumpOffBtn		Btn8D
#define clawForwardBtn		Btn7R	//directly sets claw power to clawDefPower
#define clawBackwardBtn		Btn7L	//directly sets claw power to -clawDefPower
#define clawNeutralBtn		Btn7U	//directly sets claw power to 0
#define openClawBtn				Btn6U
#define closeClawBtn			Btn6D
#define hyperExtendBtn		Btn7D
	//#endsubregion
	//#subregion lift
#define liftUpBtn		Btn5U
#define liftDownBtn	Btn5D
	//#endsubregion
//#endregion

//#region enums
enum liftState { BOTTOM, MIDDLE, TOP, THROW, MAX };
enum clawState { CLOSED, OPEN, HYPEREXTENDED };
//#endregion

//#region positions
int liftPositions[5] = { 1050, 1650, 2400, 2425, 2950 };	//same order as corresponding enums
int clawPositions[3] = { 400, 1150, 2000 };
//#endregion

//#region constants
#define liftStillSpeed 10
#define clawDefPower 80	//power used in manual control
#define liftErrorMargin 150	//margins of error
#define clawErrorMargin 50
#define maxStationarySpeed	100	//max error decrease in claw PID error (per second) where claw is considered not to be moving (CURRENTLY UNUSED)
#define fenceToWallDist 28
#define clawDiff 0					//difference between claw potentiometers when at the same angle (left - right)
#define liftDriftDist	300	//estimated distance lift drifts after button is released (for setting lift PID target during drive control)
//#endregion

//#region config
#define straightToCube true
#define blocking false
#define driverPID false
//#endregion

//#region timers
#define autonTimer T1
#define movementTimer T2
//#region

//#region globals
bool autoDumping = true;
int autoSign; //for autonomous, positive if robot is left of pillow
clawState currentState;

motorGroup lift;
motorGroup rightClaw;
motorGroup leftClaw;
//#endregion

void pre_auton() {
	bStopTasksBetweenModes = true;

	initializeAutoMovement();

	turnDefaults.rampConst1 = 40;
	turnDefaults.rampConst2 = 127;
	turnDefaults.rampConst3 = -30;

	driveDefaults.rampConst1 = 50;
	driveDefaults.rampConst2 = 120;
	driveDefaults.rampConst3 = -20;

	//configure drive
	initializeDrive(drive);
	setDriveMotors(drive, 6, ld1, ld2, ld2, rd1, rd2, rd3);
	attachEncoder(drive, leftEnc, LEFT);
	attachEncoder(drive, rightEnc, RIGHT, false, 2.75);
	attachGyro(drive, hyro);

	//configure lift
	initializeGroup(lift, 3, lift1, lift2, lift3);
	configureButtonInput(lift, liftUpBtn, liftDownBtn, liftStillSpeed);
	addSensor(lift, liftPot);

	//configure claw sides
	initializeGroup(rightClaw, 1, clawR);
	setTargetingPIDconsts(rightClaw, 0.2, 0, 0.7/25, 25);
	addSensor(rightClaw, clawPotR);

	initializeGroup(leftClaw, 1, clawL);
	setTargetingPIDconsts(leftClaw, 0.2, 0, 0.7/25, 25);
	addSensor(leftClaw, clawPotL);
}

void inactivateTargets() {
	stopTargeting(lift);
	stopTargeting(rightClaw);
	stopTargeting(leftClaw);
}

//#region lift
void setLiftState(liftState state) {
	setTargetPosition(lift, liftPositions[state]);
}

void setLiftPIDmode(bool auto) {
	if (auto)
		setTargetingPIDconsts(lift, 0.4, 0.001, 0.6, 25);
	else
		setTargetingPIDconsts(lift, 0.2, 0.001, 0.2, 25);
}

void liftControl() {
	if (driverPID) {
		if (vexRT[liftUpBtn] == 1) {
			setPower(lift, 127);
			setTargetPosition(lift, limit(getPosition(lift)+liftDriftDist, liftPositions[BOTTOM], liftPositions[MAX]));
		} else if (vexRT[liftDownBtn] == 1) {
			setPower(lift, -127);
			setTargetPosition(lift, limit(getPosition(lift)-liftDriftDist, liftPositions[BOTTOM], liftPositions[MAX]));
		} else {
			maintainTargetPos(lift);
		}
	} else {
		lift.stillSpeed = liftStillSpeed * (getPosition(lift)<liftPositions[MIDDLE] ? -1 : 1);

		takeInput(lift);
	}
}
//#endregion

//#region claw
void executeClawPIDs() {
	maintainTargetPos(leftClaw);
	maintainTargetPos(rightClaw);
}

void setClawState(clawState state) {
	setTargetPosition(leftClaw, clawPositions[state]+clawDiff);
	setTargetPosition(rightClaw, clawPositions[state]);
	currentState = state;
}

void setClawTargets(int targetPos) {
	setTargetPosition(leftClaw, targetPos+clawDiff);
	setTargetPosition(rightClaw, targetPos);
}

void setClawPower(int power, bool setTargets=true) {
	setPower(leftClaw, power);
	setPower(rightClaw, power);

	if (setTargets) setClawTargets(getPosition(rightClaw));
}

void clawControl() {
	if (vexRT[clawNeutralBtn] == 1) {
		setClawPower(0);
	} else if (vexRT[forwardBtn] == 1) {
		setPower(clawDefPower);
	} else	if (vexRT[backwardBtn] == 1) {
		setPower(-clawDefPower);
	} else if (vexRT[openClawBtn]==1 && currentState!=OPEN)
		setClawState(OPEN);
	else if (vexRT[closeClawBtn]==1 && currentState!=CLOSED)
		setClawState(CLOSED);
	else if (vexRT[hyperExtendBtn]==1 && currentState!=HYPEREXTENDED)
		setClawState(HYPEREXTENDED);
	else if (getPosition(lift)>liftPositions[THROW] && currentState!=OPEN && autoDumping)
		setClawState(OPEN);
	else {
		executeClawPIDs();
	}

	if (vexRT[autoDumpOnBtn] == 1)
		autoDumping = true;
	else if (vexRT[autoDumpOffBtn] == 1)
		autoDumping = false;
}
//#endregion

//#region autonomous
task maneuvers() {
	while (true) {
		executeClawPIDs();

		maintainTargetPos(lift);

		EndTimeSlice();
	}
}

bool clawNotMoving(motorGroup *claw, int maxSpeed=maxStationarySpeed) {
	float speed = (abs(claw->posPID.target - getPosition(claw)) - abs(claw->posPID.prevError)) * 1000 / time(claw->posPID.lastUpdated);
	return speed < maxSpeed;
}

bool clawIsClosed(int maxSpeed=maxStationarySpeed) {
	return getPosition(rightClaw)<clawPositions[OPEN] /*&& clawNotMoving(rightClaw, maxSpeed)*/
					&& getPosition(leftClaw)<clawPositions[OPEN]+clawDiff /*&& clawNotMoving(leftClaw, maxSpeed)*/;
}

bool liftNotReady() { return !errorLessThan(lift, liftErrorMargin); }

bool clawNotReady() {
	if (rightClaw.posPID.target < clawPositions[OPEN])	//assuming this is representative of both claw sides
		return !clawIsClosed();
	else
		return !(errorLessThan(rightClaw, clawErrorMargin) || errorLessThan(leftClaw, clawErrorMargin));
}

void waitForMovementToFinish(bool waitForClaw=true, bool waitForLift=true, bool waitForDrive=true, int timeout=75) {
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if ((liftNotReady() && waitForLift) || (clawNotReady() && waitForClaw))
			clearTimer(movementTimer);
		EndTimeSlice();
	}

	while (turnData.isTurning || driveData.isDriving) EndTimeSlice();
}

void liftTo(liftState state, int timeout=75) {
	setLiftState(state);
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if (liftNotReady())
			clearTimer(movementTimer);
		EndTimeSlice();
	}
}

void moveClawTo(clawState state, int timeout=75) {
	setClawState(state);
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if (clawNotReady())
			clearTimer(movementTimer);
		EndTimeSlice();
	}
}

void turnDriveDump (int angle, int dist, int distCutoff=0, float turnConst1=turnDefaults.rampConst1, float turnConst2=turnDefaults.rampConst2, float turnConst3=turnDefaults.rampConst3) {
	if (angle != 0) { //turning
		if (dist != 0) { //turning & driving
			if (lift.posPID.target < liftPositions[MIDDLE])
				liftTo(MIDDLE); //lift up so claw doesn't drag on ground
			turn(angle, false, turnConst1, turnConst2, turnConst3); //turn
		} else { //turning but not driving
			turn(angle, true, turnConst1, turnConst2, turnConst3); //turn
			while (abs(turnProgress()) < distCutoff) EndTimeSlice(); //wait to throw
		}
	}

	if (dist != 0) { //driving
		driveStraight(dist, true); //drive
		while (driveData.totalDist<distCutoff && driveData.isDriving) EndTimeSlice(); //wait to throw
	}

	setLiftState(MAX);
	while (getPosition(lift) < liftPositions[THROW]) EndTimeSlice();
	setClawState(OPEN);
	waitForMovementToFinish();
}

void grabNdump(int delayDuration, int dist=fenceToWallDist, int closeTimeout=500) {
	wait1Msec(delayDuration); //wait for objects to be dropped
	moveClawTo(CLOSED, closeTimeout);
	turnDriveDump(0, -dist); //dump pillow
}

void driveToWall(int distance=fenceToWallDist) {
	liftTo(BOTTOM);
	driveStraight(distance);
}

void ramToRealign(int duration=500) {
	liftTo(BOTTOM);

	setDrivePower(drive, -127, -127); //realign using wall
	wait1Msec(duration);
	setDrivePower(drive, 0, 0);
}

void initialPillow() {
	if (straightToCube) {
		driveStraight(22);
	} else {
		//open claw and drive away from wall
		driveStraight(5, true);
		while (driveData.isDriving) EndTimeSlice();

		//drive to central pillow
		turn(autoSign * -47, true);
		waitForMovementToFinish();
		driveStraight(14);
	}

	moveClawTo(CLOSED, 100); //clamp pillow
}

task skillz() {
	setClawState(OPEN);
	driveStraight(-11, true);
	while(driveData.isDriving);
	liftTo(MIDDLE);
	liftTo(BOTTOM);

	grabNdump(3000);

	for (int i=0; i<2; i++) { //dump preload pillows
		ramToRealign();

		driveStraight(fenceToWallDist);

		grabNdump(500);
	}

	ramToRealign();

	//get and dump front center jacks
	setTargetPosition(lift, liftPositions[MIDDLE]+10);
	setClawState(OPEN);
	driveStraight(4.5, true);
	waitForMovementToFinish(false);
	turn(-44, true, 40, 90, -20);
	waitForMovementToFinish();
	liftTo(BOTTOM);
	driveStraight(29);
	moveClawTo(CLOSED);
	wait1Msec(500);
	liftTo(MIDDLE);
	//driveStraight(-5);
	turnDriveDump(50, 0, 30, 40, 100, -20);

	//get and dump pillow in center of field
	setLiftState(MIDDLE);
	ramToRealign();
	setLiftState(BOTTOM);
	waitForMovementToFinish();
	driveStraight(8);
	moveClawTo(CLOSED); //grab pillow
	turnDriveDump(0, -10);

	//grab and dump center back jacks
	driveStraight(fenceToWallDist+1.5, true);
	setClawState(HYPEREXTENDED);
	setLiftState(BOTTOM);
	waitForMovementToFinish();
	grabNdump(0, 30, 750);

	//get and dump right side pillow
	setLiftState(BOTTOM);
	turn(-15, true);
	waitForMovementToFinish();
	driveStraight(37);
	moveClawTo(CLOSED);
	turnDriveDump(15, -30, 10);

	//for redundancy
	ramToRealign();
	driveStraight(fenceToWallDist);
	grabNdump(500);

	//get first right side jack
	setLiftState(MIDDLE);
	driveStraight(4, true);
	waitForMovementToFinish();
	turn(-80);
	liftTo(BOTTOM);
	driveStraight(7);

	//get second side jack
	turn(80);
	driveStraight(fenceToWallDist);
	grabNdump(0);

	//for redundancy
	ramToRealign();
	driveStraight(fenceToWallDist);
	grabNdump(500);

	liftTo(BOTTOM);
}

task pillowAuton() {
	clearTimer(autonTimer);
	initialPillow();

	//go to fence and lift up
	setLiftState(TOP);
	driveStraight(7, true, 40, 95, -30);
	while (driveData.isDriving) EndTimeSlice();
	wait1Msec(500);
	turn(autoSign * 35, true, 40, 100, -30); //turn to face fence
	while (turnData.isTurning) EndTimeSlice();
	driveStraight(28, true, 60, 127, -20); // drive up to wall
	waitForMovementToFinish();
	wait1Msec(750);

	if (blocking) {
		setDrivePower(drive, 15, 15);
		while (time1(autonTimer) < 15000) EndTimeSlice();
	}
	moveClawTo(OPEN); //release pillow
	wait1Msec(1500); //wait for pillow to fall
	moveClawTo(CLOSED);
	driveStraight(-8); //back up
	moveClawTo(HYPEREXTENDED);
	/*liftTo(MAX);
	setClawState(HYPEREXTENDED);
	driveStraight(-10, true); //back up
	waitForMovementToFinish();
	liftTo(TOP);*/

	//push jacks over
 	driveStraight(9);
 	moveClawTo(CLOSED);

 	setClawState(HYPEREXTENDED);

 	//drive to other wall
 	setTargetPosition(lift, liftPositions[TOP]+100);
 	driveStraight(-10, true);
 	while (driveData.isDriving) EndTimeSlice();
 	turn(autoSign * 65, true, 60, 127, -20);
 	waitForMovementToFinish();
 	driveStraight(45);
 	turn(autoSign * -65, false, 40, 120, -40);
 	driveStraight(20);

 	moveClawTo(CLOSED);
 	liftTo(MAX);
 	//driveStraight(-10);
 	//liftTo(BOTTOM);
}

task dumpyAuton() {
	initialPillow();

	liftTo(MIDDLE);
	driveStraight(9);

	turnDriveDump(autoSign * -100, -17, 7, 45, 100, -20);
	wait1Msec(100);
	ramToRealign();

	setLiftState(BOTTOM);
	setClawState(HYPEREXTENDED);
	waitForMovementToFinish();
	driveStraight(fenceToWallDist+5);
	grabNdump(0, 33, 750);
	driveToWall();
	grabNdump(0, 33, 750);

	liftTo(BOTTOM);
}

task oneSideAuton() {
	setTargetPosition(lift, liftPositions[TOP]-450); //lift to near top
	driveStraight(-5, true); //drive away from wall
	while(driveData.isDriving) EndTimeSlice();

	turn(autoSign * 30, true);
	while (turnData.isTurning) EndTimeSlice();

	driveStraight(-12, true);
	waitForMovementToFinish(false);

	turn(autoSign * -30, true); //turn toward wall
	waitForMovementToFinish();

	//knock off jacks
	driveStraight(-25);
	liftTo(MAX);
	moveClawTo(CLOSED);

	//pick up and dump back jacks
	setClawState(OPEN);
	setLiftState(BOTTOM);
	waitForMovementToFinish();
	//turn(autoSign * -3);
	driveStraight(29);
	moveClawTo(CLOSED);
	turnDriveDump(autoSign * 0, -35, 20);
}

task autonomous() {
	inactivateTargets();
	setLiftPIDmode(true);
	startTask(maneuvers);

	int sidePos = SensorValue[sidePot];
	int modePos = SensorValue[modePot];

	autoSign = sgn(1770 - sidePos);

	//start appropriate autonomous task
	if (1150<sidePos && sidePos<2415) {
		startTask(skillz);
	} else if (modePos < 1130) {
		startTask(pillowAuton);
	} else if (modePos < 2525) {
		startTask(dumpyAuton);
	}

	while (true) EndTimeSlice();
}
//#endregion

task usercontrol() {
	inactivateTargets();
	setLiftPIDmode(false);

	while (true) {
		driveRuntime(drive);

		liftControl();

		clawControl();
	}
}
