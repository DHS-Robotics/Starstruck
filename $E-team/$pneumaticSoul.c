#pragma config(Sensor, in1,    hyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    sidePot,        sensorPotentiometer)
#pragma config(Sensor, in6,    modePot,        sensorPotentiometer)
#pragma config(Sensor, in7,    clawPotL,       sensorPotentiometer)
#pragma config(Sensor, in8,    clawPotR,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           rDrive1,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LDrive1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LClaw,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rDrive2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LDrive2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LDrive3,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int debug;
//#region config
	//#subregion user control
//#define DRIVER_PID	//uncommented if using PID instead of still speeds during user control
	//#endsubregion
	//#subregion auton
#define straightToCube true	//whether initialPillow() drives straight to cube
#define agressiveClose false	//determines the point at which the claw begins to close in initialPillow()
#define skills false	//whether autonomous mode runs skills routine
	//#endsubregion
	//#subregion tuning
#define TUNING	//uncommented to use tuning function
	//#endsubregion
//#endregion

//#region setup
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#include "..\Includes\pd_autoMove.c"
//#endregion

//#region buttons
	//#subregion claw
#define autoDumpOnBtn			Btn8U
#define autoDumpOffBtn		Btn8D
#define clawForwardBtn		Btn7R	//directly sets claw power to clawDefPower
#define clawBackwardBtn		Btn7L	//directly sets claw power to -clawDefPower
#define clawNeutralBtn		Btn7U	//directly sets claw power to 0
#define openClawBtn				Btn6U
#define closeClawBtn			Btn6D
#define hyperExtendBtn		Btn7D
	//#endsubregion
	//#subregion lift
#define liftUpBtn		Btn5U
#define liftDownBtn	Btn5D
	//#endsubregion
//#endregion

//#region positions
enum liftState { BOTTOM, MIDDLE, TOP, THROW, MAX };
enum clawState { CLOSED, OPEN, HYPEREXTENDED };

int liftPositions[5] = { 1025, 1860, 2280, 2160, 2725 };	//same order as corresponding enums
int clawPositions[3] = { 350, 1285, 1900 };
//#endregion

#ifdef TUNING
	int targets[4] = { liftPositions[MIDDLE], clawPositions[OPEN], 0, 0 };	//lift, claw, turn, drive
	bool abortDrive = false;	//set to true to stop drive maneuver
	bool abortTuning = false;
#endif

//#region constants
#define liftStillSpeed 15
#define clawDefPower 80	//power used in manual control
#define liftErrorMargin 150	//margins of error
#define clawErrorMargin 100
#define maxStationarySpeed	100	//max error decrease in claw PID error (per second) where claw is considered not to be moving (CURRENTLY UNUSED)
#define fenceToWallDist 30
#define clawDiff 120					//difference between claw potentiometers when at the same angle (left - right)
#define liftDriftDist	300	//estimated distance lift drifts after button is released (for setting lift PID target during drive control)
//#endregion

//#region timers
#define autonTimer T1
#define movementTimer T2
//#region

//#region globals
bool autoDumping = false;
clawState currentState;
int liftDirection;
bool autonVariant = false; //whether using standard or variant auton routine
int timeToBlock;	//amount of time (ms) after the beginning of blocking auton after which robot will release the cube

motorGroup lift;
motorGroup rightClaw;
motorGroup leftClaw;
//#endregion

void pre_auton() {
	bStopTasksBetweenModes = true;

	initializeAutoMovement();

	//configure drive
	initializeDrive(drive, true);
	setDriveMotors(drive, 6, LDrive1, LDrive2, LDrive3, rDrive1, rDrive2, rDrive2);
	attachEncoder(drive, leftEnc, LEFT);
	attachEncoder(drive, rightEnc, RIGHT, false, 3.25);
	attachGyro(drive, hyro);

	//configure lift
	initializeGroup(lift, 3, lift1, lift2, lift3);
	configureButtonInput(lift, liftUpBtn, liftDownBtn, liftStillSpeed);
	addSensor(lift, liftPot);

	//configure claw sides
	initializeGroup(rightClaw, 1, rClaw);
	setTargetingPIDconsts(rightClaw, 0.2, 0, 0.7/25, 25);
	addSensor(rightClaw, clawPotR);

	initializeGroup(leftClaw, 1, LClaw);
	setTargetingPIDconsts(leftClaw, 0.2, 0, 0.7/25, 25);
	addSensor(leftClaw, clawPotL);
}

void inactivateTargets() {
	stopTargeting(lift);
	stopTargeting(rightClaw);
	stopTargeting(leftClaw);
}

//#region lift
void setLiftState(liftState state) {
	setTargetPosition(lift, liftPositions[state]);
}

void setLiftPIDmode(bool auto) {
	if (auto)
		setTargetingPIDconsts(lift, 0.3, 0.0005, 0.15, 25);
	else
		setTargetingPIDconsts(lift, 0.2, 0.001, 0.2, 25);
}

void liftControl() {
	#ifdef DRIVER_PID
		if (vexRT[liftUpBtn] == 1) {
			setPower(lift, 127);
			setTargetPosition(lift, limit(getPosition(lift)+liftDriftDist, liftPositions[BOTTOM], liftPositions[MAX]));
		} else if (vexRT[liftDownBtn] == 1) {
			setPower(lift, -127);
			setTargetPosition(lift, limit(getPosition(lift)-liftDriftDist, liftPositions[BOTTOM], liftPositions[MAX]));
		} else {
			maintainTargetPos(lift);
		}
	#else
		if (vexRT[liftUpBtn] == 1) {
			setPower(lift, 127);
			liftDirection = 1;
		} else if (vexRT[liftDownBtn] == 1) {
			setPower(lift, -127);
			liftDirection = -1;
		} else {
			setPower(lift, liftDirection * liftStillSpeed);
		}
	#endif
}
//#endregion

//#region claw
void executeClawPIDs() {
	maintainTargetPos(leftClaw);
	maintainTargetPos(rightClaw);
}

void setClawTargets(int targetPos) {
	setTargetPosition(leftClaw, targetPos+clawDiff);
	setTargetPosition(rightClaw, targetPos);
}

void setClawState(clawState state) {
	setClawTargets(clawPositions[state]);
	currentState = state;
}

void setClawPower(int power, bool setTargets=true) {
	setPower(leftClaw, power);
	setPower(rightClaw, power);

	if (setTargets) setClawTargets(getPosition(rightClaw));
}

void clawControl() {
	if (vexRT[clawNeutralBtn] == 1) {
		setClawPower(0);
	} else if (vexRT[clawForwardBtn] == 1) {
		setClawPower(clawDefPower);
	} else	if (vexRT[clawBackwardBtn] == 1) {
		setClawPower(-clawDefPower);
	} else if (vexRT[openClawBtn]==1 && currentState!=OPEN)
		setClawState(OPEN);
	else if (vexRT[closeClawBtn]==1 && currentState!=CLOSED)
		setClawState(CLOSED);
	else if (vexRT[hyperExtendBtn]==1 && currentState!=HYPEREXTENDED)
		setClawState(HYPEREXTENDED);
	else if (getPosition(lift)>liftPositions[THROW] && currentState!=OPEN && autoDumping)
		setClawState(OPEN);
	else {
		executeClawPIDs();
	}

	if (vexRT[autoDumpOnBtn] == 1)
		autoDumping = true;
	else if (vexRT[autoDumpOffBtn] == 1)
		autoDumping = false;
}
//#endregion

//#region autonomous
task maneuvers() {
	while (true) {
		executeClawPIDs();

		/*if (lift.posPID.target==liftPositions[BOTTOM] && errorLessThan(lift, 50))
			setPower(lift, -liftStillSpeed);
		else*/
			maintainTargetPos(lift);

		EndTimeSlice();
	}
}

bool clawNotMoving(motorGroup *claw, int maxSpeed=maxStationarySpeed) {
	float speed = (abs(claw->posPID.target - getPosition(claw)) - abs(claw->posPID.prevError)) * 1000 / time(claw->posPID.lastUpdated);
	return speed < maxSpeed;
}

bool clawIsClosed(int maxSpeed=maxStationarySpeed) {
	return getPosition(rightClaw) < clawPositions[OPEN] /*&& clawNotMoving(rightClaw, maxSpeed)*/
					&& getPosition(leftClaw) < clawPositions[OPEN]+clawDiff /*&& clawNotMoving(leftClaw, maxSpeed)*/;
}

bool liftNotReady() { return !errorLessThan(lift, liftErrorMargin); }

bool clawNotReady() {
	if (rightClaw.posPID.target == clawPositions[CLOSED])	//assuming this is representative of both claw sides
		return !clawIsClosed();
	else
		return !(errorLessThan(rightClaw, clawErrorMargin) || errorLessThan(leftClaw, clawErrorMargin));
}

void waitForMovementToFinish(bool waitForClaw=true, bool waitForLift=true, bool waitForDrive=true, int timeout=75) {
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if ((liftNotReady() && waitForLift) || (clawNotReady() && waitForClaw))
			clearTimer(movementTimer);
		EndTimeSlice();
	}

	while (turnData.isTurning || driveData.isDriving) EndTimeSlice();
}

void liftTo(liftState state, int timeout=75) {
	setLiftState(state);
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if (liftNotReady())
			clearTimer(movementTimer);
		EndTimeSlice();
	}
}

void moveClawTo(clawState state, int timeout=75) {
	setClawState(state);
	clearTimer(movementTimer);

	while (time1(movementTimer) < timeout) {
		if (clawNotReady())
			clearTimer(movementTimer);
		EndTimeSlice();
	}
}

void turnDriveDump (int angle, int dist, int distCutoff=0, float turnConst1=turnDefaults.rampConst1, float turnConst2=turnDefaults.rampConst2, float turnConst3=turnDefaults.rampConst3) {
	if (angle != 0) { //turning
		if (dist != 0) { //turning & driving
			if (lift.posPID.target < liftPositions[MIDDLE])
				liftTo(MIDDLE); //lift up so claw doesn't drag on ground
			turn(angle, false, turnConst1, turnConst2, turnConst3); //turn
		} else { //turning but not driving
			turn(angle, true, turnConst1, turnConst2, turnConst3); //turn
			while (abs(turnProgress()) < distCutoff) EndTimeSlice(); //wait to throw
		}
	}

	if (dist != 0) { //driving
		driveStraight(dist, true); //drive
		while (driveData.totalDist<distCutoff && driveData.isDriving) EndTimeSlice(); //wait to throw
	}

	setLiftState(MAX);
	while (getPosition(lift) < liftPositions[THROW]) EndTimeSlice();
	setClawState(OPEN);
	waitForMovementToFinish();
}

void grabNdump(int delayDuration, int dist=fenceToWallDist, int closeTimeout=500) {
	wait1Msec(delayDuration); //wait for objects to be dropped
	moveClawTo(CLOSED, closeTimeout);
	turnDriveDump(0, -dist); //dump pillow
}

void ramToRealign(int duration=500) {
	setDrivePower(drive, -127, -127); //realign using wall
	wait1Msec(duration);
	setDrivePower(drive, 0, 0);
}

#ifdef TUNING
void tuning() {
	while (!abortTuning) {
		if (targets[0] != lift.posPID.target)
			setTargetPosition(lift, targets[0]);

		if (targets[1] != rightClaw.posPID.target)
			setClawTargets(targets[1]);

		if (abortDrive) {
			abortDrive = false;
			driveData.isDriving = false;
			turnData.isTurning = false;
			setDrivePower(drive, 0, 0);
		}

		if (!(driveData.isDriving || turnData.isTurning)) {
			if (targets[2] != 0) {
				turn(targets[2], true);
				targets[2] = 0;
			} else if (targets[3] != 0) {
				driveStraight(targets[3], true);
				targets[3] = 0;
			}
		}
	}
}
#endif

void initialPillow(bool deployScoop=false) {
	if (deployScoop) {
		setTargetPosition(lift, liftPositions[MIDDLE]-200);
		waitForMovementToFinish(false);
		setLiftState(BOTTOM);
	}	else {
		setLiftState(BOTTOM);
	}

	if (agressiveClose)
		setClawState(OPEN);

	if (straightToCube) {
		driveStraight(26, true);
		while (driveData.totalDist < 15);
		setClawState(OPEN);
		while (driveData.isDriving);
	} else {
		//open claw and drive away from wall
		driveStraight(6, true);
		while (driveData.isDriving) EndTimeSlice();

		//drive to central pillow
		turn(-47, true);
		waitForMovementToFinish();
		driveStraight(17);
	}

	moveClawTo(CLOSED, 500); //clamp pillow
}

void initialSide(bool skillz=false) {	//dumps preload and corner jack first if preloadFirst is true
  //back up
  driveStraight(-35, true);
  setLiftState(MIDDLE);
  setClawTargets(clawPositions[OPEN] - 350);
  waitForMovementToFinish(false);

  //get corner jacks
  setLiftState(BOTTOM);
  turn(-20);
  driveStraight(26);
  waitForMovementToFinish();
  moveClawTo(CLOSED);
  while (getPosition(rightClaw) > 600);

  //dump
  //setLiftState(MIDDLE);
  setTargetPosition(lift, liftPositions[MIDDLE]-200);
  if (skills) {
  	driveStraight(-29);
  	turn(13);
  	driveStraight(10);
  	turnDriveDump(0, -35, 5);
  } else {
  	driveStraight(-15);
  	turnDriveDump(13, -25, 5);
  }
}

task skillz() {
	turnDefaults.reversed = true;
	initialSide(true);

	for (int i=0; i<3; i++) { //dump preload pillows
		moveClawTo(CLOSED, 250);
		setLiftState(BOTTOM);
		ramToRealign();

		setClawState(OPEN);
		driveStraight(fenceToWallDist + 1.5);

		grabNdump(500);
	}

	setLiftState(BOTTOM);
	ramToRealign();

	//get and dump front center jacks
	setTargetPosition(lift, liftPositions[MIDDLE]+100);	//TODO
	setClawTargets(clawPositions[OPEN] - 300);
	ramToRealign();
	driveStraight(3, true);
	waitForMovementToFinish(false);
	turn(75, true, 40, 90, -30);
	waitForMovementToFinish();
	liftTo(BOTTOM);
	//setTargetPosition(lift, 1110);	//so claw rolls along bottom bar
	driveStraight(42);
	moveClawTo(CLOSED, 600);
	setTargetPosition(lift, liftPositions[MIDDLE]+250);
	driveStraight(-6);
	turnDriveDump(-75, -5, 0, 40, 95, -30);

	//get and dump pillow in center of field
	setLiftState(MIDDLE);
	ramToRealign(750);
	liftTo(BOTTOM, 250);
	driveStraight(15);
	moveClawTo(CLOSED, 500); //grab pillow
	turnDriveDump(0, -17);

	//grab and dump center back jacks
	setClawState(HYPEREXTENDED);
	setLiftState(BOTTOM);
	ramToRealign();
	driveStraight(fenceToWallDist+5, true);
	waitForMovementToFinish();
	grabNdump(0, fenceToWallDist+3, 750);

	//get and dump right side pillow
	setLiftState(BOTTOM);
	ramToRealign();
	driveStraight(3);
	turn(17, true);
	waitForMovementToFinish();
	driveStraight(40);
	moveClawTo(CLOSED);
	turnDriveDump(-17, -fenceToWallDist-10, 10);

	//get first right side jack
	setLiftState(MIDDLE);
	ramToRealign();
	driveStraight(5, true);
	waitForMovementToFinish();
	turn(50);
	liftTo(BOTTOM);
	driveStraight(10);

	//get second side jack
	turn(-50);
	driveStraight(fenceToWallDist);
	grabNdump(0, fenceToWallDist+5);

	//for redundancy
	for (int i=5; true; i+=5) {
		setLiftState(BOTTOM);
		ramToRealign();
		driveStraight(fenceToWallDist + i);
		grabNdump(500);
	}

	/*//clean sweep
	setLiftState(BOTTOM);
	setClawState(HYPEREXTENDED);
	ramToRealign();
	driveStraight(25);
	turn(-60);
	driveStraight(100);
	moveClawTo(CLOSED);
	turnDriveDump(60, -30, 5);*/
}

task blockingAuton() {	//variant blocks for nearly entire autonomous period, variant on fat angel triggers this and blocks for ~1/2
	clearTimer(autonTimer);
	initialPillow();

	//go to fence and lift up
	setLiftState(TOP);
	driveStraight(10, false, 40, 95, -30);
	wait1Msec(100);
	turn(45, false, 40, 100, -30); //turn to face fence
	driveStraight(30, false, 60, 127, -20); // drive up to wall
	waitForMovementToFinish();

	while (time1(autonTimer) < timeToBlock)
		setDrivePower(drive, 15, 15);

	moveClawTo(OPEN); //release pillow
	wait1Msec(750); //wait for pillow to fall
	setClawState(CLOSED);
	driveStraight(-7, true); //back up
	while (driveData.totalDist < 5);
	setClawState(HYPEREXTENDED);
	waitForMovementToFinish();

	//push jacks over
 	driveStraight(10);
 	moveClawTo(OPEN);

 	driveStraight(-5);
 	turn(140);
 	setLiftState(BOTTOM);
 	setClawState(HYPEREXTENDED);
 	waitForMovementToFinish();
 	driveStraight(fenceToWallDist + 3);
 	grabNdump(0);
	debug = time1(T4);
 	//liftTo(BOTTOM);
}

task dumpyAuton() {	//variant dumps to side
	initialPillow(true);

	liftTo(MIDDLE);
	driveStraight(11, false, 40, 95, -30);

	turnDriveDump((autonVariant ? -55 : -95), -24, 7, 45, 100, -20);
	setClawState(HYPEREXTENDED);
	setLiftState(BOTTOM);

	if (autonVariant) {
		driveStraight(20);
		turn(-10);
	} else {
		ramToRealign();
	}

	waitForMovementToFinish();
	driveStraight(autonVariant ? 15 : fenceToWallDist+6);
	grabNdump(0, fenceToWallDist+10, 750);

	setDrivePower(drive, -15, -15);	//block
	/*setLiftState(BOTTOM);	//for redundancy
	ramToRealign();
	driveStraight(fenceToWallDist);
	grabNdump(0, fenceToWallDist, 750);

	liftTo(BOTTOM);*/
}

task oneSideAuton() {	//variant doesn't get center back jacks
  initialSide(false);

  if (!autonVariant) {
    //drive to back
    setClawTargets(clawPositions[OPEN] - 300);
    setLiftState(MIDDLE);
    ramToRealign();
    driveStraight(fenceToWallDist + 15);

    //get and dump back center jacks
    turn(50);
    setLiftState(BOTTOM);
    driveStraight(-4);
    waitForMovementToFinish();
    driveStraight(50);
    moveClawTo(CLOSED);
    while (getPosition(rightClaw) > 600);
    setLiftState(MIDDLE);
    driveStraight(-40);
    turnDriveDump(-50, -fenceToWallDist-15, 13);
  }
}

task fatAngel() {	//no variant
  initialSide(true);

  //center cube
  setLiftState(BOTTOM);
  turn(35);
  waitForMovementToFinish();
  driveStraight(30);
  moveClawTo(CLOSED);
  liftTo(MIDDLE);
  driveStraight(6, false, 40, 90, -20);
  //wait1Msec(500);
  turnDriveDump(-30, -30, 10);

  //center back jacks
  setClawState(HYPEREXTENDED);
  liftTo(BOTTOM);
  driveStraight(fenceToWallDist);
  moveClawTo(CLOSED);
  turnDriveDump(0, -fenceToWallDist-5, 1);
}

task autonomous() {
	inactivateTargets();
	setLiftPIDmode(true);
	startTask(maneuvers);

	int sidePos = SensorValue[sidePot];
	int modePos = SensorValue[modePot];
	clearTimer(T4);	//debug

	//tuning();
	//start appropriate autonomous task
	if (skills) {
		startTask(skillz);
	} else	if (1500>sidePos || sidePos>2200) {
		turnDefaults.reversed = sidePos <= 1875;
		autonVariant = 400<sidePos && sidePos<3600;	//true if in upper half of potentiometer

		if (modePos < 450) {
			timeToBlock = (autonVariant ? 14000 : 5500);
			startTask(blockingAuton);
		} else if (modePos < 1970) {
			startTask(dumpyAuton);
		} else if (modePos < 3645) {
			startTask(oneSideAuton);
		} else {
			if (!autonVariant) {
				startTask(fatAngel);
			} else {
				timeToBlock = 9000;
				startTask(blockingAuton);
			}
		}
	}

	setClawPower(0);
	setPower(lift, 0);
	setDrivePower(drive, 0, 0);

	while (true) EndTimeSlice();
}
//#endregion

task usercontrol() {
	inactivateTargets();
	setClawPower(0);
	setPower(lift, 0);
	setLiftPIDmode(false);

	while (true) {
		driveRuntime(drive);

		liftControl();

		clawControl();
	}
}
