#pragma config(Sensor, in2,    hyro,           sensorPotentiometer)
#pragma config(Sensor, in3,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    modePot,        sensorPotentiometer)
#pragma config(Sensor, in6,    sidePot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           rd1,           tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rd2,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lift5,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           ld1,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ld2,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//#region includes
#include "..\Includes\motorGroup.c"
#include "..\Includes\parallelDrive.c"
#include "..\Includes\pd_autoMove.c"
//#endregion

//#region buttons
#define openClawBtn Btn6U //claw
#define closeClawBtn Btn6D
#define liftUpBtn Btn5U //lift
#define liftDownBtn Btn5D
//#endregion

//#region positions
#define liftBottom 75 //lift
#define liftTop 1100
#define liftMiddle 285
#define liftVert 1822
#define clawOpenPos 2890 //claw
#define clawClosedPos 3475
#define clawMax 2180
//#endregion

//#region constants
#define liftUpPower 127 //lift
#define liftDownPower -60
#define liftStillSpeed 10 //still speeds
#define clawStillSpeed 15
//#endregion

//#region globals
bool clawOpen = false;
short autoSign; //for autonomous, positive if robot is left of pillow

motorGroup lift;
motorGroup claw;
//#endregion

void pre_auton() {
	bStopTasksBetweenModes = true;

	//configure drive
	initializeDrive(drive);
  setDriveMotors(drive, 4, ld1, ld2, rd1, rd2);
  attachEncoder(drive, leftEnc, LEFT);
  attachEncoder(drive, rightEnc, RIGHT, false, 4);
  attachGyro(drive, hyro);

  //configure lift
	initializeGroup(lift, 5, lift1, lift2, lift3, lift4, lift5);
  configureButtonInput(lift, liftUpBtn, liftDownBtn, liftStillSpeed, liftUpPower, liftDownPower);
  addSensor(lift, liftPot);

	//configure claw
  initializeGroup(claw, 1, clawMotor);
  addSensor(claw, clawPot);
}

//#region claw
void clawControl() {
	if (vexRT[closeClawBtn] == 1) {
		setPower(claw, 127);
		clawOpen = false;
	} else if (vexRT[openClawBtn] == 1) {
		setPower(claw, -127);
		clawOpen = true;
	} else {
		setPower(claw, clawStillSpeed * (clawOpen ? -1 : 1));
	}
}
//#endregion

//#region autonomous
task maneuvers() {
	while (true) {
		executeManeuver(claw);
		executeManeuver(lift);
	}
}

void setClawStateManeuver(bool open) { //toggles by default
	if (open) {
		createManeuver(claw, clawOpenPos, -clawStillSpeed);
	} else {
		createManeuver(claw, clawClosedPos, clawStillSpeed);
	}

	clawOpen = open;
}

void openClaw(bool stillSpeed=true) {
	goToPosition(claw, clawOpenPos, (stillSpeed ? -clawStillSpeed : 0));
}

void closeClaw(bool stillSpeed=true) {
	goToPosition(claw, clawClosedPos, (stillSpeed ? clawStillSpeed : 0));
}

void hyperExtendClaw(bool stillSpeed=true) {
	goToPosition(claw, clawMax, (stillSpeed ? -clawStillSpeed : 0));
}

void setLiftStateManeuver(bool top) {
  if (top) {
    createManeuver(lift, liftTop, liftStillSpeed);
  } else {
    createManeuver(lift, liftBottom, liftStillSpeed);
  }
}

void grabNdump(int delayDuration) {
	wait1Msec(delayDuration); //wait for objects to be dropped
	closeClaw();
	createManeuver(lift, liftVert, -liftStillSpeed); //lift to top
	driveStraight(-40, true); //drive to fence
	while (driveData.isDriving || lift.maneuverExecuting);
	openClaw();
}

void driveToWall() {
	goToPosition(lift, liftBottom, -liftStillSpeed);
	driveStraight(39);
}

task skillz() {
	setClawStateManeuver(true);
	driveStraight(-20, true); //drive back
	while (driveData.isDriving || claw.maneuverExecuting);

	for (int i=1; i<=3; i++) { //throw all preloads
		grabNdump(500);

		if (i < 3) {
			driveToWall();
		}
	}

	//get pillow in center of field
	setLiftStateManeuver(false);
	createManeuver(claw, clawOpenPos-200, -clawStillSpeed);
	while (lift.maneuverExecuting || claw.maneuverExecuting);
	turn(-38, false, 40, 127, -10);
	driveStraight(20);
	closeClaw(); //grab pillow

	//dump pillow
	createManeuver(lift, liftVert, -liftStillSpeed);
	turn(45, true);
	while (turnData.isTurning);
	driveStraight(-10, true);
	while (driveData.isDriving || lift.maneuverExecuting);
	openClaw();

	//grab and dump jacks
	driveToWall();
	grabNdump(0);
	goToPosition(lift, liftBottom);
}

task pillowAuton() {
	//open claw, drive away from wall, and lift up a little bit
	setClawStateManeuver(true);
	createManeuver(lift, 100, liftStillSpeed, 35);
  driveStraight(10, true);
  while(driveData.isDriving || lift.maneuverExecuting);

  //drive to central pillow
  turn(-53, true);
  while(turnData.isTurning || claw.maneuverExecuting);
  driveStraight(20);

  closeClaw(); //clamp pillow

	//go to fence and lift up
  setLiftStateManeuver(true);
  driveStraight(24, true);
  while (driveData.isDriving);
  turn(63, true, 40, 80, -10); //turn to face fence
  while (turnData.isTurning);
  driveStraight(36, true); // drive up to wall
  while (driveData.isDriving || lift.maneuverExecuting);

  openClaw(); //release pillow
  wait1Msec(600); //wait for pillow to fall
  closeClaw();
  driveStraight(-10); //back up
  hyperExtendClaw();

  //push jacks over
 	driveStraight(10);
 	closeClaw();

 	createManeuver(claw, clawMax, -clawStillSpeed);

 	//drive to other wall and lift down
 	driveStraight(-15, true);
 	while (driveData.isDriving);
 	turn(77, true, 40, 127, -20);
 	while (turnData.isTurning || claw.maneuverExecuting);
 	createManeuver(lift, 761, liftStillSpeed);
 	driveStraight(55, true);
 	while (driveData.isDriving || lift.maneuverExecuting);
 	turn(-77, false, 40, 120, -40);
 	driveStraight(10);

 	goToPosition(lift, 1466); //push jacks over
 	driveStraight(12.5);
 	closeClaw();
}

task oneSideAuton() {
	createManeuver(claw, clawMax, -clawStillSpeed); //open claw
	createManeuver(lift, liftTop-450, liftStillSpeed); //lift to near top
  driveStraight(5, true); //drive away from wall
  while(driveData.isDriving);

  turn(-30, true);
  while (turnData.isTurning);

  driveStraight(18, true);
  while (driveData.isDriving || claw.maneuverExecuting);

  turn(37, true); //turn toward wall
  while (turnData.isTurning || lift.maneuverExecuting);

  //knock off jacks
  driveStraight(42);
  goToPosition(lift, 1250, liftStillSpeed);
  closeClaw();
  wait1Msec(2500);

  //go to back jacks
 	setClawStateManeuver(true);
 	turn(120, true, 40, 127, -10);
 	while (turnData.isTurning);
 	setLiftStateManeuver(false);
 	driveStraight(46, true);
 	while (driveData.isDriving || lift.maneuverExecuting || claw.maneuverExecuting);
 	closeClaw();
 	wait1Msec(3500);

 	//dump
 	createManeuver(lift, liftVert, -liftStillSpeed);
 	turn(50, true);
 	while (turnData.isTurning);
 	driveStraight(-30, true);
 	while(driveData.isDriving || lift.maneuverExecuting);
 	openClaw();
 	goToPosition(lift, liftBottom);
}

task autonomous() {
	lift.maneuverExecuting = false;
	claw.maneuverExecuting = false;
	startTask(maneuvers);

  autoSign = (SensorValue[sidePot] < 1800) ? 1 : -1;

  //start appropriate autonomous task
  if (SensorValue[sidePot] > 1575) {
  	startTask(skillz);
  } else if (SensorValue[modePot] > 2670) {
  	startTask(pillowAuton);
  } else if (SensorValue[modePot] > 1275) {
  	startTask(oneSideAuton);
  }
}
//#endregion

task usercontrol() {
	while (true) {
  	driveRuntime(drive);

  	takeInput(lift);

		clawControl();
  }
}
